<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>軌道要素</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
input[type="number"] { width: 90% }
html { width: 100%; height: 100%; }
body {
  width: 100%; height: 100%;
  margin: 0; padding: 0;
  color: white;
  font-size: small;
}

#app {
  width: 100%; height: 100%;
  margin: 0; padding: 0;
  display: flex;
  flex-direction: row;
}

#app h1 {
  position: absolute;
  top: 10px;
  left: 10px;
  color: white;
  z-index: 100;
}

.blocks {
  display: flex;
  flex-direction: row;
}

.block {
  width: 100vw;
  height: 100vh;
}

@media screen and (max-width:720px) {
  .blocks {
    flex-direction: column;
  }
  .block {
    width: 100vw;
    height: 50vh;
  }
  .hide-small-display {
    display: none;
  }
}

.svg svg {
  width: 100%; height: 100%;
  background-color: #030108;
}

#gl {
  flex: 1;
}

#controller {
  position: fixed;
  top: 20px;
  right: 20px;
  border: 1px solid green;
  padding: 10px;
  background-color: white;
  color: black;
  font-size: small;
}
  </style>
</head>
<body>
  <div id="app" style="display:flex; flex-direction:column;">
    <h1>軌道要素</h1>
    <div class="blocks">
      <div class="block" id="gl">
        <div style="position:absolute">
          <label>
            <input type="checkbox" v-model="usePerspective" @change="updatePerspective">
            Perspective
          </label>
        </div>
      </div>
    </div>
    <div id="controller">
      <div for="a" style="display:flex">
        <div style="flex:1">軌道長半径<span class="hide-small-display">(a)</span></div>
        <div style="width:4em">
          <input v-if="e < 1.0" v-model="a" type="number" step="0.1" min="0.1" :disabled="1.0 <= e" />
          <input v-else value="使用不可" :disabled="1.0 <= e" style="width:4em" />
        </div>
      </div>
      <div for="a" style="display:flex">
        <div style="flex:1">近点距離<span class="hide-small-display">(q)</span></div>
        <div style="width:4em">
          <input v-model="q" type="number" step="0.1" min="0.1" />
        </div>
      </div>
      <div for="e" style="display:flex">
        <div style="flex:1">離心率<span class="hide-small-display">(e)</span></div>
        <div style="width:4em">
          <input v-model="e" type="number" step="0.01" min="0.00" />
        </div>
      </div>
      <div for="i" style="display:flex">
        <div style="flex:1">近点引数<span class="hide-small-display">(peri)</span></div>
        <div style="width:4em">
          <input v-model="peri" type="number" step="1.0" min="0.0" max="360.0" />
        </div>
      </div>
      <div for="i" style="display:flex">
        <div style="flex:1">軌道傾斜角<span class="hide-small-display">(incl)</span></div>
        <div style="width:4em">
          <input v-model="incl" type="number" step="1.0" min="0.0" max="180.0" />
        </div>
      </div>
      <div for="W" style="display:flex">
        <div style="flex:1">昇交点黄経<span class="hide-small-display">(node)</span></div>
        <div style="width:4em">
          <input v-model="node" type="number" step="1.0" min="0.0" max="360.0" />
        </div>
      </div>
    </div>
  </div>
  <!-- <script src="https://unpkg.com/vue@3"></script> -->
  <script src="https://unpkg.com/vue@3.2.31/dist/vue.global.prod.js"></script>
  <script src="https://unpkg.com/three@0.138.3/build/three.js"></script>
  <script src="https://unpkg.com/three@0.138.3/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.meshline/1.4.0/THREE.MeshLine.min.js" integrity="sha512-xcjV55ij0+bQJJ2I8yazZ4EqX5xQ2jSePFtzuCFrw6rmTTuRngsTQFLyopwcRrTZ4oWxGW6zeuMKMgLWoT9bIw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
const { createApp, ref, computed, watch, onMounted } = Vue
createApp({
  setup() {
    const solarRadius = ref(3)
    const solarColor  = ref('#ff0')
    // const a      = ref(1.0)
    const q      = ref(0.2)
    const e      = ref(0.8)
    const peri   = ref(0.0)
    const incl   = ref(0.0)
    const node   = ref(0.0)
    const f      = ref(150)

    const a = computed({
      get: () => {
        if (1.0 <= e.value) { return }
        return q.value / (1 - e.value)
      },
      set: (a) => {
        if (1.0 <= e.value) { return }
        q.value = a * (1 - e.value)
      }
    })

    const usePerspective = ref(true)

    const smallDevice = 720
    const width  = ref(window.innerWidth)
    const height = ref(window.innerHeight)
    const tr     = ref(2.41)
    const z      = ref(f.value * 9)

    // # WebGL Rendering Objects
    // scene
    const scene = new THREE.Scene()

    // light
    const light = new THREE.DirectionalLight(0xffffff, 1)
    light.position.set(0, 0, 1)
    scene.add(light)

    const ambient = new THREE.AmbientLight(0x909090)
    scene.add(ambient);

    // axis
    scene.add(new THREE.Line(
      new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(f.value * 2, 0, 0),
      ]),
      new THREE.LineBasicMaterial({color: 0xffff00})
    ))
    scene.add(new THREE.Line(
      new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, f.value * 2, 0),
      ]),
      new THREE.LineBasicMaterial({color: 0x000099})
    ))
    scene.add(new THREE.Line(
      new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, f.value * 2),
      ]),
      new THREE.LineBasicMaterial({color: 0x990000})
    ))

    scene.add(new THREE.Mesh(
      new THREE.PlaneGeometry(f.value * 2, f.value * 2, 1, 1),
      new THREE.MeshLambertMaterial({
        color: 0x333333,
        transparent: true, opacity: 0.5,
        side: THREE.DoubleSide})
    ))

    // additional lines
    const nodeLine = new THREE.Line(
      new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(f.value / 2, 0, 0),
      ]),
      new THREE.LineBasicMaterial({color: 0x00ff00})
    )
    scene.add(nodeLine)

    const inclLine = new THREE.Line(
      new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, f.value / 2),
      ]),
      new THREE.LineBasicMaterial({color: 0xff0000})
    )
    scene.add(inclLine)

    const periLine = new THREE.Line(
      new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(f.value / 2, 0, 0),
      ]),
      new THREE.LineBasicMaterial({color: 0x0000ff})
    )
    scene.add(periLine)

    // additional plane
    const orbitalPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(f.value * 2, f.value * 2, 1, 1),
      new THREE.MeshLambertMaterial({color: 0x0000cc, transparent: true, opacity: 0.3, side: THREE.DoubleSide})
    )
    scene.add(orbitalPlane)

    // orbit
    const orbit = new THREE.Group()
    scene.add(orbit)

    const getOrbitalPoint = (t) => {
      const l = e.value == 1.0 ? q.value * 2 : 1 - Math.pow(e.value, 2)
      const r = (e.value == 1.0 ? 1.0 : q.value / ( 1 - e.value )) * l / (1 + e.value * Math.cos(t))
      const x = f.value * r * Math.cos(t)
      const y = f.value * r * Math.sin(t)
      return new THREE.Vector3(x, y, 0)
    }

    const updateOrbit = () => {
      if (0 < orbit.children.length) {
        for (let child of orbit.children) {
          orbit.remove(child)
        }
      }

      const sz = 1000
      const points = []
      const nearest = getOrbitalPoint(0)
      const o = new THREE.Vector3(0, 0, 0)
      let prev
      for (let i = 0; i <= sz; i++) {
        const p = getOrbitalPoint((2 * i / sz - 1 ) * Math.PI)
        if (nearest.x < p.x) { continue }
        if (1000 < p.distanceTo(o)) { continue }
        if (prev && prev.distanceTo(p) < 5) { continue }

        points.push(p)
        prev = p
      }

      const curve = new THREE.CatmullRomCurve3(points)
      const geom = new MeshLine()
      geom.setPoints(curve.getPoints(1000))

      orbit.add(new THREE.Mesh(
        geom,
        new MeshLineMaterial({
          lineWidth: 2.0,
          color: 0x303030,
          dashArray: 0.05,
          dashOffset: 0,
          dashRatio: 0.5,
        })
      ))
    }
    updateOrbit()

    watch([q, e], updateOrbit)
    watch([node, incl, peri], () => {
      const q = new THREE.Quaternion()

      const qn = new THREE.Quaternion().setFromAxisAngle(
        new THREE.Vector3(0, 0, 1),
        (node.value / 180) * Math.PI
      )
      q.multiply(qn)
      nodeLine.quaternion.set(q.x, q.y, q.z, q.w)

      const qi = new THREE.Quaternion().setFromAxisAngle(
        new THREE.Vector3(1, 0, 0),
        (incl.value / 180) * Math.PI
      )
      q.multiply(qi)
      inclLine.quaternion.set(q.x, q.y, q.z, q.w)
      orbitalPlane.quaternion.set(q.x, q.y, q.z, q.w)

      const qp = new THREE.Quaternion().setFromAxisAngle(
        new THREE.Vector3(0, 0, 1),
        (peri.value / 180) * Math.PI
      )
      q.multiply(qp)
      periLine.quaternion.set(q.x, q.y, q.z, q.w)

      orbit.quaternion.set(q.x, q.y, q.z, q.w)
    })

    // camera
    const aspect = width.value / height.value

    const pCam = new THREE.PerspectiveCamera(30, aspect, 10, 50000)
    pCam.position.set(0, 0, z.value)
    scene.add(pCam)

    const oCam = new THREE.OrthographicCamera(
      -f.value * tr.value * aspect, f.value * tr.value * aspect,
      f.value * tr.value, -f.value * tr.value,
      -10000, 10000
    )
    oCam.position.set(0, 0, z.value)
    scene.add(oCam)

    // control
    let updatePerspective = ref(() => {})

    onMounted(() => {
      // Rendering area
      const elem = document.getElementById('gl')
      const renderer = new THREE.WebGLRenderer()
      renderer.setClearColor(0x030108, 1.0)
      renderer.setSize(width.value, height.value)
      elem.appendChild(renderer.domElement)

      // control
      let control = new THREE.OrbitControls(usePerspective.value ? pCam : oCam, elem)
      updatePerspective.value = () => {
        if (control) { control.dispose() }
        control = new THREE.OrbitControls(usePerspective.value ? pCam : oCam, elem)
      }

      // render flame
      const renderFrame = () => {
        requestAnimationFrame(renderFrame)

        for (let child of orbit.children){
          child.material.uniforms.dashOffset.value -= 0.001
        }

        renderer.render(scene, usePerspective.value ? pCam : oCam)
      }

      renderFrame()

      window.addEventListener('resize', () => {
        width.value  = window.innerWidth
        height.value = window.innerHeight

        const aspect = width.value / height.value

        renderer.setSize(width.value, height.value)
        renderer.setPixelRatio(aspect)

        pCam.aspect = aspect
        pCam.updateProjectionMatrix()

        oCam.left   = -f.value * tr.value * aspect
        oCam.right  =  f.value * tr.value * aspect
        oCam.top    =  f.value * tr.value
        oCam.bottom = -f.value * tr.value
        oCam.updateProjectionMatrix()
      })
    })

    return {
      solarRadius, solarColor,
      a, q, e, peri, incl, node, f,
      width, height,
      usePerspective, updatePerspective
    }
  }
}).mount('#app')
  </script>
</body>
</html>
